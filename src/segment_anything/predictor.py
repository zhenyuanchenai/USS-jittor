import numpy as np
import jittor as jt

from .modeling import Sam

from typing import Optional, Tuple

from .utils.transforms import ResizeLongestSide


class SamPredictor:
    def __init__(
        self,
        sam_model: Sam,
    ) -> None:
      
        super().__init__()
        self.model = sam_model
        self.transform = ResizeLongestSide(sam_model.image_encoder.img_size)
        self.reset_image()

    def set_image(
        self,
        image: np.ndarray,
        image_format: str = "RGB",
    ) -> None:

        assert image_format in [
            "RGB",
            "BGR",
        ], f"image_format must be in ['RGB', 'BGR'], is {image_format}."
        if image_format != self.model.image_format:
            image = image[..., ::-1]

        # Transform the image to the form expected by the model
        input_image = self.transform.apply_image(image)
        input_image_jt = jt.array(input_image)
        input_image_jt = input_image_jt.permute(2, 0, 1)[None, :, :, :]
        self.set_jittor_image(input_image_jt, image.shape[:2])

    @jt.no_grad()
    def set_jittor_image(
        self,
        transformed_image: jt.Var,
        original_image_size: Tuple[int, ...],
    ) -> None:

        assert (
            len(transformed_image.shape) == 4
            and transformed_image.shape[1] == 3
            and max(*transformed_image.shape[2:]) == self.model.image_encoder.img_size
        ), f"set_jt_image input must be BCHW with long side {self.model.image_encoder.img_size}."
        self.reset_image()

        self.original_size = original_image_size
        self.input_size = tuple(transformed_image.shape[-2:])
        input_image = self.model.preprocess(transformed_image)
        self.features = self.model.image_encoder(input_image)
        self.is_image_set = True

    def predict(
        self,
        point_coords: Optional[np.ndarray] = None,
        point_labels: Optional[np.ndarray] = None,
        box: Optional[np.ndarray] = None,
        mask_input: Optional[np.ndarray] = None,
        multimask_output: bool = True,
        return_logits: bool = False,
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        
        if not self.is_image_set:
            raise RuntimeError("An image must be set with .set_image(...) before mask prediction.")

        # Transform input prompts
        coords_jt, labels_jt, box_jt, mask_input_jt = None, None, None, None
        if point_coords is not None:
            assert (
                point_labels is not None
            ), "point_labels must be supplied if point_coords is supplied."
            point_coords = self.transform.apply_coords(point_coords, self.original_size)
            coords_jt = jt.array(point_coords, dtype=np.float32)
            labels_jt = jt.array(point_labels, dtype=np.int32)
            coords_jt, labels_jt = coords_jt[None, :, :], labels_jt[None, :]
        if box is not None:
            box = self.transform.apply_boxes(box, self.original_size)
            box_jt = jt.array(box, dtype=np.float32)
            box_jt = box_jt[None, :]
        if mask_input is not None:
            mask_input_jt = jt.array(mask_input, dtype=np.float32)
            mask_input_jt = mask_input_jt[None, :, :, :]

        masks, iou_predictions, low_res_masks = self.predict_jittor(
            coords_jt,
            labels_jt,
            box_jt,
            mask_input_jt,
            multimask_output,
            return_logits=return_logits,
        )

        masks_np = masks[0].data
        iou_predictions_np = iou_predictions[0].data
        low_res_masks_np = low_res_masks[0].data
        return masks_np, iou_predictions_np, low_res_masks_np
    
    @jt.no_grad()
    def predict_jittor(
        self,
        point_coords: Optional[jt.Var],
        point_labels: Optional[jt.Var],
        boxes: Optional[jt.Var] = None,
        mask_input: Optional[jt.Var] = None,
        multimask_output: bool = True,
        return_logits: bool = False,
    ) -> Tuple[jt.Var, jt.Var, jt.Var]:
        
        if not self.is_image_set:
            raise RuntimeError("An image must be set with .set_image(...) before mask prediction.")
        
        if point_coords is not None:
            points = (point_coords, point_labels)
        else:
            points = None
            
        # Embed prompts 对的
        sparse_embeddings, dense_embeddings = self.model.prompt_encoder(
            points=points,
            boxes=boxes,
            masks=mask_input,
        )
        
        # Predict masks
        low_res_masks, iou_predictions = self.model.mask_decoder(
            image_embeddings=self.features,
            image_pe=self.model.prompt_encoder.get_dense_pe(),
            sparse_prompt_embeddings=sparse_embeddings,
            dense_prompt_embeddings=dense_embeddings,
            multimask_output=multimask_output,
        )

        # Upscale the masks to the original image resolution
        masks = self.model.postprocess_masks(low_res_masks, self.input_size, self.original_size)
        
        if not return_logits:
            masks = masks > self.model.mask_threshold

        return masks, iou_predictions, low_res_masks

    def get_image_embedding(self) -> jt.Var:

        if not self.is_image_set:
            raise RuntimeError(
                "An image must be set with .set_image(...) to generate an embedding."
            )
        assert self.features is not None, "Features must exist if an image has been set."
        return self.features

    @property
    def device(self):
        return self.model.device()

    def reset_image(self) -> None:
        """Resets the currently set image."""
        self.is_image_set = False
        self.features = None
        self.orig_h = None
        self.orig_w = None
        self.input_h = None
        self.input_w = None